// Adaptive Gamification System with ML-powered Personalization
// Enhances existing achievement system while maintaining backward compatibility

import { Achievement, UserAchievement, AchievementTier } from '@/lib/types'

// Enhanced achievement interface (extends existing)
export interface AdaptiveAchievement extends Achievement {
  difficulty: 'easy' | 'medium' | 'hard' | 'expert'
  personalityMatch: number // 0-1 score for user personality match
  adaptiveRequirement?: number // Dynamically adjusted requirement
  timeEstimate?: number // Estimated time to complete (hours)
  prerequisites?: string[] // Achievement IDs that should be completed first
  motivationalStyle: 'challenge' | 'progress' | 'social' | 'mastery'
  aiGenerated?: boolean // Whether this achievement was generated by AI
}

// User behavior patterns for personalization
export interface UserBehaviorPattern {
  userId: string
  sessionPatterns: {
    averageSessionLength: number
    preferredWorkingHours: number[]
    peakProductivityTime: string
    sessionsPerWeek: number
  }
  achievementPatterns: {
    completionRate: number
    averageTimeToComplete: number
    preferredDifficulty: 'easy' | 'medium' | 'hard' | 'expert'
    motivationType: 'intrinsic' | 'extrinsic' | 'social'
  }
  contentPreferences: {
    preferredGenres: string[]
    averageBPM: number
    energyPreference: number // 0-100
    complexityPreference: number // 0-100
  }
  personalityProfile: {
    openness: number // 0-1
    conscientiousness: number // 0-1
    extroversion: number // 0-1
    agreeableness: number // 0-1
    neuroticism: number // 0-1
  }
  productivityMetrics: {
    averageProjectCompletionTime: number
    beatsPerSession: number
    qualityScore: number // Based on complexity and variety
    consistencyScore: number // How regular they are
  }
}

// Adaptive difficulty system
export class AdaptiveDifficultyEngine {
  private readonly DIFFICULTY_ADJUSTMENT_RATE = 0.1
  private readonly MIN_COMPLETION_RATE = 0.3
  private readonly MAX_COMPLETION_RATE = 0.8

  // Analyze user behavior to determine optimal difficulty
  calculateOptimalDifficulty(
    userPattern: UserBehaviorPattern,
    recentAchievements: UserAchievement[]
  ): 'easy' | 'medium' | 'hard' | 'expert' {
    const { completionRate, averageTimeToComplete } = userPattern.achievementPatterns
    
    // Factor in recent performance
    const recentPerformance = this.calculateRecentPerformance(recentAchievements)
    
    // Adjust based on completion rate
    let difficultyScore = 0.5 // Start at medium
    
    if (completionRate > this.MAX_COMPLETION_RATE) {
      difficultyScore += 0.2 // Increase difficulty
    } else if (completionRate < this.MIN_COMPLETION_RATE) {
      difficultyScore -= 0.2 // Decrease difficulty
    }
    
    // Factor in average completion time
    const avgTimeNormalized = Math.min(averageTimeToComplete / (7 * 24), 1) // Normalize to week scale
    if (avgTimeNormalized < 0.3) {
      difficultyScore += 0.1 // Quick completer, can handle more
    } else if (avgTimeNormalized > 0.8) {
      difficultyScore -= 0.1 // Slow completer, ease up
    }
    
    // Factor in recent performance
    difficultyScore += recentPerformance * 0.1
    
    // Factor in conscientiousness (more conscientious users can handle harder challenges)
    difficultyScore += userPattern.personalityProfile.conscientiousness * 0.15
    
    // Map score to difficulty levels
    if (difficultyScore < 0.25) return 'easy'
    if (difficultyScore < 0.5) return 'medium'
    if (difficultyScore < 0.75) return 'hard'
    return 'expert'
  }

  private calculateRecentPerformance(recentAchievements: UserAchievement[]): number {
    if (recentAchievements.length === 0) return 0
    
    const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000)
    const recentAchievements30Days = recentAchievements.filter(
      a => new Date(a.unlocked_at).getTime() > thirtyDaysAgo
    )
    
    return Math.min(recentAchievements30Days.length / 5, 1) // Normalize to 5 achievements per month
  }

  // Adjust achievement requirements based on user performance
  adaptRequirement(
    baseRequirement: number,
    userPattern: UserBehaviorPattern,
    difficulty: 'easy' | 'medium' | 'hard' | 'expert'
  ): number {
    const multipliers = {
      easy: 0.7,
      medium: 1.0,
      hard: 1.4,
      expert: 2.0
    }
    
    let adjustedRequirement = baseRequirement * multipliers[difficulty]
    
    // Fine-tune based on user's productivity patterns
    const productivityMultiplier = userPattern.productivityMetrics.consistencyScore
    adjustedRequirement *= (0.8 + productivityMultiplier * 0.4) // 0.8-1.2 range
    
    return Math.max(1, Math.round(adjustedRequirement))
  }
}

// AI-powered achievement generation
export class AIAchievementGenerator {
  private readonly ACHIEVEMENT_TEMPLATES = [
    {
      category: 'production' as const,
      templates: [
        { name: 'Beat Explorer', description: 'Create beats in {count} different genres', requirement: 3, icon: 'üåç' },
        { name: 'Tempo Master', description: 'Create {count} beats with BPM between {bpmMin}-{bpmMax}', requirement: 5, icon: '‚ö°' },
        { name: 'Harmonic Genius', description: 'Use {count} different key signatures', requirement: 4, icon: 'üéπ' },
        { name: 'Energy Architect', description: 'Create {count} high-energy beats (80%+ energy)', requirement: 3, icon: 'üî•' }
      ]
    },
    {
      category: 'streak' as const,
      templates: [
        { name: 'Daily Creator', description: 'Create beats for {count} consecutive days', requirement: 7, icon: 'üìÖ' },
        { name: 'Weekly Warrior', description: 'Complete {count} productive weeks', requirement: 4, icon: 'üí™' },
        { name: 'Session Specialist', description: 'Complete {count} focused sessions this month', requirement: 15, icon: 'üéØ' }
      ]
    },
    {
      category: 'time' as const,
      templates: [
        { name: 'Marathon Producer', description: 'Spend {count} hours in production this week', requirement: 10, icon: '‚è∞' },
        { name: 'Speed Creator', description: 'Complete a beat in under {count} minutes', requirement: 30, icon: '‚ö°' },
        { name: 'Deep Focus', description: 'Complete a {count}-hour uninterrupted session', requirement: 3, icon: 'üßò' }
      ]
    }
  ]

  // Generate personalized achievements based on user behavior
  generatePersonalizedAchievements(
    userPattern: UserBehaviorPattern,
    existingAchievements: Achievement[],
    count: number = 3
  ): AdaptiveAchievement[] {
    const generatedAchievements: AdaptiveAchievement[] = []
    const adaptiveDifficultyEngine = new AdaptiveDifficultyEngine()
    
    for (let i = 0; i < count && generatedAchievements.length < count; i++) {
      // Select appropriate category based on user preferences
      const category = this.selectCategoryForUser(userPattern)
      const templates = this.ACHIEVEMENT_TEMPLATES.find(t => t.category === category)?.templates || []
      
      if (templates.length === 0) continue
      
      const template = templates[Math.floor(Math.random() * templates.length)]
      
      // Generate achievement based on template and user data
      const baseRequirement = this.calculateBaseRequirement(template.requirement, userPattern, category)
      const difficulty = adaptiveDifficultyEngine.calculateOptimalDifficulty(userPattern, [])
      const adaptiveRequirement = adaptiveDifficultyEngine.adaptRequirement(baseRequirement, userPattern, difficulty)
      
      const achievement: AdaptiveAchievement = {
        id: `ai_${Date.now()}_${i}`,
        name: this.personalizeAchievementName(template.name, userPattern),
        description: this.personalizeDescription(template.description, adaptiveRequirement, userPattern),
        icon: template.icon,
        tier: this.selectTierForDifficulty(difficulty),
        category,
        requirement: adaptiveRequirement,
        difficulty,
        personalityMatch: this.calculatePersonalityMatch(template, userPattern),
        adaptiveRequirement,
        timeEstimate: this.estimateTimeToComplete(category, adaptiveRequirement, userPattern),
        motivationalStyle: this.selectMotivationalStyle(userPattern),
        aiGenerated: true
      }
      
      // Ensure uniqueness
      if (!this.isDuplicate(achievement, existingAchievements, generatedAchievements)) {
        generatedAchievements.push(achievement)
      }
    }
    
    return generatedAchievements.sort((a, b) => b.personalityMatch - a.personalityMatch)
  }

  private selectCategoryForUser(userPattern: UserBehaviorPattern): Achievement['category'] {
    const { personalityProfile, achievementPatterns } = userPattern
    
    // High conscientiousness users like systematic progress
    if (personalityProfile.conscientiousness > 0.7) {
      return Math.random() > 0.5 ? 'streak' : 'time'
    }
    
    // High openness users like variety and exploration
    if (personalityProfile.openness > 0.7) {
      return 'production'
    }
    
    // Extroverted users might like social achievements
    if (personalityProfile.extroversion > 0.7) {
      return 'social'
    }
    
    // Default to what they've been successful with
    if (achievementPatterns.completionRate > 0.7) {
      return 'production' // They're doing well, challenge them with creation
    }
    
    return 'time' // Focus on building habits
  }

  private calculateBaseRequirement(
    templateRequirement: number,
    userPattern: UserBehaviorPattern,
    category: Achievement['category']
  ): number {
    switch (category) {
      case 'production':
        return Math.max(1, Math.round(templateRequirement * userPattern.productivityMetrics.beatsPerSession))
      case 'streak':
        return Math.max(1, Math.round(templateRequirement * userPattern.productivityMetrics.consistencyScore))
      case 'time':
        return Math.max(1, Math.round(templateRequirement * (userPattern.sessionPatterns.averageSessionLength / 60)))
      default:
        return templateRequirement
    }
  }

  private personalizeAchievementName(name: string, userPattern: UserBehaviorPattern): string {
    const { preferredGenres } = userPattern.contentPreferences
    const { personalityProfile } = userPattern
    
    // Add personality-based prefixes
    if (personalityProfile.openness > 0.8) {
      return `Creative ${name}`
    } else if (personalityProfile.conscientiousness > 0.8) {
      return `Dedicated ${name}`
    } else if (personalityProfile.extroversion > 0.8) {
      return `Social ${name}`
    }
    
    // Add genre-specific touches if applicable
    if (preferredGenres.length > 0 && name.includes('Beat')) {
      const primaryGenre = preferredGenres[0]
      return name.replace('Beat', `${primaryGenre} Beat`)
    }
    
    return name
  }

  private personalizeDescription(
    description: string,
    requirement: number,
    userPattern: UserBehaviorPattern
  ): string {
    let personalizedDescription = description
    
    // Replace placeholders
    personalizedDescription = personalizedDescription.replace('{count}', requirement.toString())
    
    // Add BPM ranges for tempo-based achievements
    if (description.includes('{bpmMin}') && description.includes('{bpmMax}')) {
      const avgBPM = userPattern.contentPreferences.averageBPM || 120
      const bpmMin = Math.max(60, avgBPM - 20)
      const bpmMax = Math.min(180, avgBPM + 20)
      personalizedDescription = personalizedDescription
        .replace('{bpmMin}', bpmMin.toString())
        .replace('{bpmMax}', bpmMax.toString())
    }
    
    return personalizedDescription
  }

  private selectTierForDifficulty(difficulty: AdaptiveAchievement['difficulty']): AchievementTier {
    const tierMap = {
      easy: 'bronze' as const,
      medium: 'silver' as const,
      hard: 'gold' as const,
      expert: 'platinum' as const
    }
    return tierMap[difficulty]
  }

  private calculatePersonalityMatch(
    template: { name: string; description: string; requirement: number },
    userPattern: UserBehaviorPattern
  ): number {
    let match = 0.5 // Base match
    
    const { personalityProfile, achievementPatterns } = userPattern
    
    // Match based on achievement type preferences
    if (template.name.includes('Explorer') || template.name.includes('Master')) {
      match += personalityProfile.openness * 0.3
    }
    
    if (template.description.includes('consecutive') || template.description.includes('streak')) {
      match += personalityProfile.conscientiousness * 0.4
    }
    
    if (template.name.includes('Social') || template.description.includes('collaborate')) {
      match += personalityProfile.extroversion * 0.3
    }
    
    // Adjust based on past completion patterns
    if (achievementPatterns.preferredDifficulty === 'hard' && template.requirement > 5) {
      match += 0.2
    } else if (achievementPatterns.preferredDifficulty === 'easy' && template.requirement <= 3) {
      match += 0.2
    }
    
    return Math.min(1, Math.max(0, match))
  }

  private estimateTimeToComplete(
    category: Achievement['category'],
    requirement: number,
    userPattern: UserBehaviorPattern
  ): number {
    const { sessionPatterns, productivityMetrics } = userPattern
    
    switch (category) {
      case 'production':
        return Math.round((requirement / productivityMetrics.beatsPerSession) * sessionPatterns.averageSessionLength)
      case 'streak':
        return requirement * 24 // Days to hours
      case 'time':
        return requirement // Already in hours
      default:
        return Math.round(requirement * 2) // Default estimate
    }
  }

  private selectMotivationalStyle(userPattern: UserBehaviorPattern): AdaptiveAchievement['motivationalStyle'] {
    const { personalityProfile, achievementPatterns } = userPattern
    
    if (personalityProfile.extroversion > 0.7) return 'social'
    if (personalityProfile.openness > 0.7) return 'mastery'
    if (achievementPatterns.motivationType === 'intrinsic') return 'challenge'
    return 'progress'
  }

  private isDuplicate(
    achievement: AdaptiveAchievement,
    existing: Achievement[],
    generated: AdaptiveAchievement[]
  ): boolean {
    const allAchievements = [...existing, ...generated]
    return allAchievements.some(a => 
      a.name === achievement.name || 
      (a.category === achievement.category && a.requirement === achievement.requirement)
    )
  }
}

// Smart goal recommendation system
export class SmartGoalRecommendationEngine {
  // Recommend optimal weekly goals based on user patterns
  recommendWeeklyGoals(userPattern: UserBehaviorPattern): {
    targetBeats: number
    targetSessionHours: number
    targetStreak: number
    confidence: number
    reasoning: string[]
  } {
    const { sessionPatterns, productivityMetrics, achievementPatterns } = userPattern
    
    const reasoning: string[] = []
    let confidence = 0.5
    
    // Calculate target beats based on current productivity
    const currentWeeklyBeats = productivityMetrics.beatsPerSession * sessionPatterns.sessionsPerWeek
    let targetBeats = Math.round(currentWeeklyBeats * 1.2) // 20% increase
    
    // Adjust based on completion rate
    if (achievementPatterns.completionRate > 0.8) {
      targetBeats = Math.round(targetBeats * 1.3)
      reasoning.push('High achievement completion rate suggests you can handle a challenge')
      confidence += 0.2
    } else if (achievementPatterns.completionRate < 0.4) {
      targetBeats = Math.round(targetBeats * 0.8)
      reasoning.push('Lower completion rate suggests a more achievable target')
      confidence -= 0.1
    }
    
    // Calculate target session hours
    const currentWeeklyHours = (sessionPatterns.averageSessionLength / 60) * sessionPatterns.sessionsPerWeek
    const targetSessionHours = Math.round(currentWeeklyHours * 1.15)
    
    // Calculate target streak
    const consistencyScore = productivityMetrics.consistencyScore
    let targetStreak = Math.round(7 * consistencyScore)
    
    if (consistencyScore > 0.8) {
      targetStreak = 7 // Full week
      reasoning.push('High consistency suggests you can maintain a daily streak')
      confidence += 0.15
    } else if (consistencyScore < 0.4) {
      targetStreak = Math.max(3, targetStreak)
      reasoning.push('Building consistency gradually with achievable streak goals')
    }
    
    // Factor in personality
    if (userPattern.personalityProfile.conscientiousness > 0.7) {
      confidence += 0.1
      reasoning.push('High conscientiousness indicates strong goal-achievement potential')
    }
    
    return {
      targetBeats: Math.max(1, targetBeats),
      targetSessionHours: Math.max(1, targetSessionHours),
      targetStreak: Math.max(1, targetStreak),
      confidence: Math.min(1, Math.max(0.2, confidence)),
      reasoning
    }
  }

  // Recommend session timing based on productivity patterns
  recommendOptimalSessionTimes(userPattern: UserBehaviorPattern): {
    recommendedTimes: string[]
    sessionDuration: number
    reasoning: string[]
  } {
    const { sessionPatterns, personalityProfile } = userPattern
    const reasoning: string[] = []
    
    // Use peak productivity time if available
    const peakTime = sessionPatterns.peakProductivityTime
    let recommendedTimes: string[] = []
    
    if (peakTime) {
      recommendedTimes.push(peakTime)
      reasoning.push(`Your peak productivity time is ${peakTime}`)
    }
    
    // Add recommendations based on personality
    if (personalityProfile.extroversion < 0.3) {
      recommendedTimes.push(...['early morning', 'late evening'])
      reasoning.push('Introverted users often prefer quieter times')
    } else {
      recommendedTimes.push(...['mid-morning', 'afternoon'])
      reasoning.push('Extroverted users often prefer more active times')
    }
    
    // Recommend session duration
    let sessionDuration = sessionPatterns.averageSessionLength
    
    if (personalityProfile.conscientiousness > 0.7) {
      sessionDuration = Math.min(sessionDuration * 1.2, 120) // Max 2 hours
      reasoning.push('High conscientiousness suggests you can handle longer sessions')
    } else if (personalityProfile.neuroticism > 0.7) {
      sessionDuration = Math.max(sessionDuration * 0.8, 25) // Min 25 minutes
      reasoning.push('Shorter sessions may help reduce anxiety and maintain focus')
    }
    
    return {
      recommendedTimes: [...new Set(recommendedTimes)], // Remove duplicates
      sessionDuration: Math.round(sessionDuration),
      reasoning
    }
  }
}

// Export utility functions for backward compatibility
export function enhanceExistingAchievements(
  achievements: Achievement[],
  userPattern: UserBehaviorPattern
): AdaptiveAchievement[] {
  const adaptiveDifficultyEngine = new AdaptiveDifficultyEngine()
  
  return achievements.map(achievement => {
    const difficulty = adaptiveDifficultyEngine.calculateOptimalDifficulty(userPattern, [])
    const adaptiveRequirement = adaptiveDifficultyEngine.adaptRequirement(
      achievement.requirement,
      userPattern,
      difficulty
    )
    
    return {
      ...achievement,
      difficulty,
      personalityMatch: 0.7, // Default for existing achievements
      adaptiveRequirement,
      timeEstimate: estimateTimeForExisting(achievement, userPattern),
      motivationalStyle: 'progress' as const,
      aiGenerated: false
    }
  })
}

function estimateTimeForExisting(achievement: Achievement, userPattern: UserBehaviorPattern): number {
  const { category, requirement } = achievement
  const { sessionPatterns, productivityMetrics } = userPattern
  
  switch (category) {
    case 'production':
      return Math.round((requirement / productivityMetrics.beatsPerSession) * sessionPatterns.averageSessionLength)
    case 'streak':
      return requirement * 24
    case 'time':
      return requirement
    default:
      return requirement * 2
  }
}